# 数组遍历

对数组进行遍历并进行求值的时候除了采用for，还可以采用 apply_along_axis

实例：

`x = np.array([[11, 12, 13, 14, 15],
              [16, 17, 18, 19, 20], 
              [21, 22, 23, 24, 25], 
              [26, 27, 28, 29, 30], 
              [31, 32, 33, 34, 35]])`

`y = np.apply_along_axis(np.sum, 0, x)`

`print(y) #[105 110 115 120 125]`

其中，np.sum，0这两个参数表示对列求和。

如果0改成1就表示对行求和



`y = np.apply_along_axis(np.mean, 0, x)`

其中，np.mean，0这两个参数表示对列求平均值。



# 数组变形

np.flatten()可以让高维数组变成一维数组。

实例：

`x = np.array([[11, 12, 13, 14, 15],
              [16, 17, 18, 19, 20], 
              [21, 22, 23, 24, 25], 
              [26, 27, 28, 29, 30], 
              [31, 32, 33, 34, 35]])`

`y = x.flatten()`

`print(y) `

`#[11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34
 35]`

在这时如果对y进行改变，y[0] = 3

这时原数组的值不会发生变化。



`np.flatten(order='F')`代表按照列展开

`np.flatten(order='C')`代表按照行展开





`np.flatten()`是拷贝，对它修改不会影响原数组。

`np.ravel(x)`代表返回的是视图，对它修改会影响原数组。

​		两者所要实现的功能是一致的（将多维数组降位一维）。

​	这点从两个单词的意也可以看出来，ravel(散开，解开)，flatten（变平）。两者的区别在于返回拷贝（copy）还是返回视图（view），numpy.flatten()返回一份拷贝，对拷贝所做的修改不会影响（reflects）原始矩阵，而numpy.ravel()返回的是视图（view，也颇有几分C/C++引用reference的意味），会影响（reflects）原始矩阵。



`np.reshape()`函数可以改变数组的形状。

比如：

`x = np.arange(12)`

`y = np.reshape(x, [3, 4])`

`print(y)`

```
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
```

如果其中有一维给定维-1，那么就会根据其列或者行来自动的做相应的适配。